# 设计模式

## 1.策略模式
官方定义：定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户

场景：模拟鸭子游戏，会出现各种鸭子，设计一个鸭子超类Duck，其他鸭子继承此超类。来了一个需求，需要让鸭子会飞，在超类Duck加上fly方法，所有鸭子便继承了fly。
但这样做会出现一些问题，在超类中加上新行为，会使不适合该行为的子类也具有该行为。比如橡皮鸭继承了fly，会飞是不科学的。当设计到维护时，为了复用目的使用继承，结局是不完美的。
换一种思路，使用接口，虽然可以解决以上问题，但是会产生大量重复代码，造成代码无法复用。

**设计原则1**：找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起
系统中某部分改变不会影响其他部分
解决：Duck仍然是鸭子超类，飞行的行为被提取出，放在其他类结构中
希望一切都能有弹性，能指定行为到鸭子的实例，应该在鸭子类中包含设定行为的方法，这样可以动态改变鸭子的行为
**设计原则2**：针对接口编程，而不是针对实现编程
以前的做法：行为来自超类的具体实现，或者是继承某个接口由子类自行实现。这样我们会被实现绑的死死的，不容易更改行为
新的做法：鸭子子类使用接口表示行为，实现不被绑死在子类中，将行为实现委托给行为类
鸭子子类不实现接口，而由行为类实现接口，这样可以将子类解除绑定，更容易扩展
具体的行为类在子类中初始化指定行为，虽然有些违背不针对实现编程，但还是很有弹性的，只是初始化不够弹性，可以在运行时改变
行为可以抽象成算法
**设计原则3**：少用组合，多用继承。“有一个”比“是一个”更好。使用组合建立系统有很大的弹性，可将算法族封装成类，还可以在运行时动态改变行为
我们总是需要花更多的时间在软件开发完成后，维护系统的变化，应该致力于提高可维护性和可扩展性

## 2.观察者模式
官方定义：定义对象之间一对多的关系，当一个对象改变时，它的所有依赖者会收到通知更新
主题是具有状态的对象，且可以控制这些状态，观察者使用这些状态
当两个对象间松耦合，它们依然可以交互，但不清楚彼此的细节。观察者模式提供一种对象设计，让主题和观察者之间松耦合，应付变化，使对象之间的依赖关系降到最低。
对于观察者，主题只知道观察者实现了某个接口，而不需要知道观察者的具体类。任何时候都可以增加观察者，主题唯一依赖的东西是实现了Observer接口的对象列表。
当新类型的观察者出现，主题代码不需要修改，只需要在新的类里实现观察者接口，注册为观察者。
**设计原则4**：为了交互对象之间的松耦合设计而努力

场景：气象监测应用，包含气象站(收集数据)，WeatherData对象(跟踪数据变化)和布告板。当指标变动，WeatherData通知到布告板。怎么通知？WeatherData调用布告板的一个方法如update来通知，所以所有布告板要实现同一个接口Observer。
变化值直接传入观察者是最直接的方法，但是观测值的种类和个数未来可能会改变，这些变化可以封装起来

但有些情况，观察者并不需要主题推数据，想根据自己的需求拉数据。


## 3.装饰者模式
场景：咖啡店有多款饮料，继承自Beverage超类。不同的饮料可加入不同的调料，加入一种调料生成一个新的子类，子类数量会爆炸。将一些共性的行为添加到基类中，子类直接用，但有些属性子类用不到。采用装饰者模式设计，比如点一个摩卡咖啡，以咖啡为主体，用摩卡对象装饰，依赖委托调整价格。

官方定义：动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案
设计好一个类，需要给类添加一些辅助功能，并不希望改变这个类的代码，此时使用装饰器模式
利用继承设计子类的行为，是在编译时静态决定的，所有子类都会继承到相同的行为。利用组合扩展对象的行为，可以在运行时动态扩展。通过动态组合对象，可写新代码添加新功能，不用修改现有代码，大大减少副作用。

**设计原则5**：类应该对扩展开放，对修改关闭
选择需要扩展的部分要小心，每个地方都采用开放-关闭原则，是一种浪费。

装饰者和被装饰者对象具有相同的超类型
可用一个或多个装饰者包装一个对象
可以用装饰者对象代替被包装的对象
装饰者可在所委托的被装饰者之前或之后，加上自己的行为
对象可在任何时候被装饰，可在运行时动态装饰对象

装饰者使用继承是为了达到类型匹配，而不是为了获得行为。装饰者使用组合添加新行为
只有依赖抽象组件类型，才不会因装饰者受影响
装饰者创建通常由工厂或生成器模式
装饰者的作用只是增加行为到包装对象，并不能感知其他装饰者

JavaIO中的很多类都是装饰者，InputStream是抽象组件，FilterInputStream是一个抽象装饰者
缺点：设计中有大量的小类，数量实在太多。采用装饰者实例化组件时，增加代码的复杂度，不只需要实例化组件，还要把组件包装进装饰者中。

继承属于扩展形式之一，但不见得是达到弹性设计的最佳方式；在设计中应该允许行为可以被扩展，而无须修改现有代码；组合和委托可用于在运行时动态添加新行为；装饰者模式意味着一群装饰者类，用来包装具体组件

## 4.工厂模式
针对接口编程，可以隔离掉系统可能发生的一大堆改变。
实例化不应该总是公开进行，初始化经常造成耦合问题。
将对象的创建过程解耦，用特定类实现
把创建对象的代码包装进一个类，当以后实现改变时，只需修改这个类。

**设计原则6**：依赖倒置原则，要依赖抽象，不要依赖具体类
当实例化一个对象时，就是在依赖它的具体类。不能让高层组件依赖低层组件，不管高层或低层，都应该依赖于抽象。
避免违反依赖倒置原则：变量不可以持有具体类的引用，用工厂避开；不要让类派生自具体类；不要覆盖基类中已实现的方法。


### 静态工厂模式
即工具类，用静态方法定义一个简单的工厂，存在缺点，不能通过继承改变创建方法的行为。
### 简单工厂模式
用单一类实现创建对象，存在的问题是，用一个类封装对象的创建过程，使用方不能自定义对象的创建过程，缺少弹性。
### 工厂方法模式
不同业务可能会有不同的对象创建方法，对象的创建由子类实现。客户程序关于超类的代码和子类对象创建代码解耦
官方定义：定义一个创建对象的接口，但由子类决定要实例化的类是哪一个，工厂方法让类把实例化推迟到子类。
### 抽象工厂模式
官方定义：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。
抽象工厂的任务是定义一个负责创建一组产品的接口，这个接口内的每个方法都负责一个具体产品，利用实现抽象工厂的子类来提供这些具体的做法。

抽象工厂模式和工厂方法模式都负责创建对象，工厂方法模式创建对象是扩展一个类，覆盖它的工厂方法，负责将客户从具体类型中解耦。抽象工厂提供一个创建产品的抽象类型，该类型的子类定义了产品被产生的方法，相比于工厂方法，可以把一群相关产品集合起来。但是加入新产品需要改变接口。


所有的工厂都是用来封装对象的创建。
工厂方法使用继承，把对象的创建委托给子类，子类实现工厂方法创建对象。
抽象工厂使用对象组合，对象的创建被实现在工厂接口暴露的方法中。
所有工厂模式都通过减少应用程序和具体类之间的依赖关系促进送耦合。
抽象工厂创建相关的对象家族，不需要依赖它们的具体类。
依赖倒置原则，指导我们避免依赖具体类型，尽量依赖抽象。
工厂方法允许将类延迟到子类进行。


## 5.单例设计模式
官方定义：确保一个类只有一个实例，并提供一个全局访问点。
单例类构造器是私有的，不能用私有构造器扩展类，不能继承。


## 6.命令模式
把方法调用封装起来，可以把运算块包装成形，调用此运算的对象不需要关心事情是如何进行的。
场景：设计一个家电遥控器，有7个可编程的插槽，每个插槽有开关，还有一个整体的撤销按钮
将发出请求的对象和接受执行请求的对象解耦
客户创建一个命令对象；客户利用setCommand()将命令对象存在调用者中；客户要求调用者执行命令。

官方定义：将请求封装成对象，以便使用不同的请求、队列或日志来参数化其他对象，支持可撤销操作
将动作请求者和动作执行者解耦

命令对象通过在特定接收者上绑定一组动作来封装一个请求，将动作和接收者包进对象中，调用方法时，接收者执行动作。
队列请求：命令可以将运算块打包传送，就像一个一般对象。一端添加命令，另一端是线程取命令，执行完丢弃命令对象，取下一个

将发出请求的对象和执行请求的对象解耦，被解耦的两者之间是通过命令对象进行沟通的。命令模式可用来实现日志和事务系统。


## 7.适配器模式
官方定义：将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。
适配器实现了目标接口，并具有被适配者的实例。
客户通过目标接口调用适配器方法，对适配器发出请求；适配器使用被适配者的接口将请求转换成被适配者的一个或多个调用接口；客户收到调用结果，并未察觉适配器起到转换作用
实现一个适配器需要的工作，和目标接口大小成正比。不用适配器，需要修改客户端代码调用新接口，将改变封装进适配器类中，是比较好的做法。
可以让客户从实现的接口解耦。如果一段时间后，我们想要改变接口，适配器可以将改变的部分封装起来，客户不必为应对不同的接口跟着修改。



## 8.外观模式
为了简化接口而改变接口，将一个或数个类的一切隐藏在背后，只显露出一个干净美好的外观。
只是提供更直接的操作，并未将原来的子系统阻隔起来。不只是简化接口，也将客户从组件的子系统解耦。
和适配器模式的区别：适配器改变接口，外观模式简化接口

官方定义：提供一个统一的接口，用来访问子系统中的一群接口。定义了一个高层接口，让子系统更加容易使用。

**设计原则7**：最少知识原则，减少对象之间的交互，只和密友谈话。
即设计系统时，不管任何对象，都要注意和它交互的类有哪些，并注意是如何交互的。不要让太多类耦合在一起，免得修改系统中的一部分会影响到其他部分。
如果对象是调用其他方法的返回结果，不要调用该对象的方法。如果这样做，相当于向该对象的子部分发送请求，增加直接认识对象的数目。改为要求该对象为我们做出请求，就不需要认识该对象的组件了。
可以调用该对象组件的方法，方法内实例化对象的方法。
但该原则会产生更多的包装类，提高开发复杂度，降低运行效率。


## 9.模板方法模式
定义了一个算法的步骤，允许子类为一个或多个步骤提供实现。
官方定义：在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。
创建一个算法的模版，模版就是一个方法，这个方法将算法定义成一组步骤，任何步骤都可以是抽象的，由子类负责实现。
当子类必须提供算法中某个方法或步骤的实现时，就使用抽象方法。钩子可以实现算法中可选的部分。
不一定要继承，子类要遵循基类的规则。

**设计原则8**：好莱坞原则，别调用我们，我们会调用你。
给出一种防止依赖腐败的方法，当高层组件依赖低层组件，而低层组件又依赖高层组件，依赖腐败就发生了。允许低层组件将自己挂钩到系统上，但高层组件会决定什么时候和怎样使用这些低层组件。

## 10.迭代器模式
让客户便遍历对象又无法窥视存储对象的方式。



## 状态模式
官方定义：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类
不变的封装，变化的用接口封装

## 建造者模式
将复杂对象的创建和表示过程分离
适用场景：
1. 多个部件可装配到一个对象中，但产生的运行结果不同
2. 初始化一个对象，参数很多，且大多有默认值
3. 产品对象内部结构复杂，且具有共性

有产品、建造者、导演三个角色。产品和建造者通常比较稳定，主要业务逻辑封装在导演类中，有新的需求，创建新的建造者类即可
和工厂设计模式类似，如果类的创建过程比较复杂，更推荐使用建造者模式

## 原型模式
用于创建重复的对象，保证性能
实现了一个原型接口，用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。
例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。
使用场景：
1. 当一个系统应该独立于它的产品创建
2. 要实例化的类是在运行时制定
3. 一个类的实例只能有几个不同状态组合的一种
通过拷贝一个现有对象生成新对象

## 享元模式
主要用于减少创建对象的数量，尝试重用现有的对象，如果未找到匹配对象，创建新对象

## 代理模式
一个类代表另一个类的功能，创建具有现有对象的对象，以便向外界提供功能接口
为其他对象提供一种代理以控制对这个对象的访问
主要解决直接访问对象时带来的问题，在访问此对象时加上一个对此对象的访问层，用于想在访问一个类时做一些控制
应用实例：买火车票不一定要去火车站，也可以找代售点
和适配器模式的区别：适配器模式主要改变所考虑对象的接口，代理模式不能改变所代理类的接口
和装饰器模式的区别：装饰器模式为了增强功能，代理模式是为了控制






