# 设计模式

## 观察者模式
定义对象之间一对多的关系，当一个对象改变时，它的所有依赖者会收到通知更新

## 工厂模式
将对象的创建过程解耦，用特定类实现
### 静态工厂模式
即工具类
### 简单工厂模式
用单一类实现创建对象
### 工厂模式
不同业务可能会有不同的对象创建方法，对象的创建由子类实现
### 抽象工厂模式
随着业务的增多，一个业务创建一个工厂子类会导致类的数量膨胀。将类分成不同的组，同一组中的类由子类的不同方法实现

## 单例设计模式
保证整个应用中只有一个实例

## 策略模式
定义了算法族，分别封装起来，让它们之间可以相互替换，让算法的变化独立于使用算法的用户
将变化的部分抽象成接口，针对接口编程，不针对实现
多用组合，少用继承

## 适配器模式
把一个接口转成另一个接口，不需要改代码，好比一个手机插头转换器，使用组合实现

## 命令模式
官方定义：将请求封装成对象，以便使用不同的请求、队列或日志来参数化其他对象，支持可撤销操作
将动作请求者和动作执行者解耦
核心是将命令封装成类

## 装饰器模式
官方定义：若要扩展功能，装饰者提供了比集成更有弹性的替代方案，动态地将责任附加到对象上。
设计好一个类，需要给类添加一些辅助功能，并不希望改变这个类的代码，此时使用装饰器模式
原则：类应该对扩展开放，对修改关闭

## 外观模式
提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层接口，让子系统更容易使用
为方便客户使用，把一群操作，封装成一个方法

## 模板方法模式
定义一个算法骨架，将一些步骤延迟到子类中，使子类可以在不改变算法结构的情况下，重新定义算法的步骤


## 状态模式
官方定义：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类
不变的封装，变化的用接口封装




